# GitHub Copilot Instructions for Azure VM Encryption Extension

## Project Context

This is the Azure VM Encryption Extension for Linux VMs. The extension provides disk encryption capabilities across multiple Linux distributions (Ubuntu, RedHat, CentOS, Oracle Linux, Azure Linux) and must maintain compatibility with the Python versions available on each target distribution.

## Code Generation Guidelines

### 1. Python Version Compatibility

**CRITICAL**: Always write Python code compatible with the oldest Python versions found on supported Linux distributions, as the extension runs on the VM's native Python environment.

**Target Compatibility**: 
- **Python 2.7**: Still present on older distributions (RHEL 7, CentOS 7, Ubuntu 14.04)
- **Python 3.x**: Standard on newer distributions (Ubuntu 18+, RHEL 8+, Azure Linux)
- **Cross-compatibility**: Code must work on both Python 2.7 and 3.x

### 2. Unit Testing Requirements

**ALWAYS** generate unit tests when creating new functions or classes. Every public method should have corresponding test coverage. Ideally coverage should be 100% whenever possible, especially for new code and critical functionality.

#### Test File Naming Convention
- Module: `MyModule.py` → Test file: `test_MyModule.py` 
- Place in `main/test/` directory
- Class naming: `class Test_MyModule(unittest.TestCase)`

#### Required Test Template
```python
import unittest
from YourModule import YourClass
from .console_logger import ConsoleLogger

try:
    import unittest.mock as mock
except ImportError:
    import mock

class Test_YourClass(unittest.TestCase):
    def setUp(self):
        self.logger = ConsoleLogger()
        self.instance = YourClass(self.logger, required_params)
    
    @mock.patch('ExternalDependency.method')
    def test_method_success(self, mock_external):
        """Test successful execution path."""
        # Arrange
        mock_external.return_value = expected_value
        
        # Act
        result = self.instance.method_under_test()
        
        # Assert
        self.assertEqual(result, expected_result)
        mock_external.assert_called_with(expected_args)
    
    @mock.patch('ExternalDependency.method')
    def test_method_error_handling(self, mock_external):
        """Test error conditions."""
        # Test exception handling
        mock_external.side_effect = Exception("Test error")
        
        with self.assertRaises(Exception):
            self.instance.method_under_test()

if __name__ == '__main__':
    unittest.main()
```

### 3. Mocking Guidelines

**Mock all external dependencies** to ensure unit tests are isolated and fast:

#### Command Execution
```python
@mock.patch('CommandExecutor.CommandExecutor.Execute')
def test_package_installation(self, mock_execute):
    # Mock command return codes
    mock_execute.side_effect = [1, 0]  # First call fails (not installed), second succeeds
    
    result = self.patcher.install_package()
    
    # Verify exact commands called
    expected_calls = [
        mock.call("rpm -q package-name"),
        mock.call("tdnf install -y package-name", timeout=100)
    ]
    mock_execute.assert_has_calls(expected_calls)
```

#### File System Operations
```python
@mock.patch('os.path.exists')
@mock.patch('os.path.isdir')
def test_file_operations(self, mock_isdir, mock_exists):
    mock_exists.return_value = True
    mock_isdir.return_value = False
    
    # Test your file operation logic
```

#### Complex File System Scenarios
```python
from .test_utils import mock_dir_structure

@mock.patch("os.path.isdir")
@mock.patch("os.listdir")
@mock.patch("os.path.exists")
def test_device_discovery(self, exists_mock, listdir_mock, isdir_mock):
    artificial_structure = {
        "/dev/disk/azure": ["root", "scsi0"],
        "/dev/disk/azure/scsi0": ["lun0", "lun1"]
    }
    mock_dir_structure(artificial_structure, isdir_mock, listdir_mock, exists_mock)
    
    # Test device discovery logic
```

### 4. Test Coverage Requirements

For every new method, create tests for:

1. **Success path**: Method works as expected
2. **Error conditions**: Handle exceptions, timeouts, missing dependencies
3. **Edge cases**: Empty inputs, boundary conditions
4. **State validation**: Verify system state after operations
5. **Mock verification**: Ensure external calls are made correctly

Example comprehensive test coverage:
```python
class Test_PackageInstaller(unittest.TestCase):
    def test_install_packages_all_installed(self):
        """Test when all packages are already installed."""
        # No installation should be attempted
    
    def test_install_packages_some_missing(self):
        """Test when some packages need installation."""
        # Only missing packages should be installed
    
    def test_install_packages_timeout(self):
        """Test timeout handling during installation."""
        # Should raise appropriate exception
    
    def test_install_packages_network_failure(self):
        """Test network failure scenarios."""
        # Should handle and report network errors
```

### 5. Logging Patterns

Use consistent logging throughout:

```python
# Info level for normal operations
self.logger.log("Starting package installation")

# Error level for failures
self.logger.log("Package installation failed: {0}".format(error_msg), level='error')

# Avoid excessive logging in production code
# Don't log every package check - only significant events
```

## Specific Domain Knowledge

### Disk Encryption Context
- This extension encrypts Linux VM disks using dmcrypt / LUKS (Linux Unified Key Setup)
- Supports both OS disk and data disk encryption
- Must handle various Linux distributions with different package managers
- Critical for customer data security - tests must be comprehensive

### Azure Extension Environment
- Runs in Azure VMs as a system extension on the VM's native Python environment
- Python version varies by Linux distribution:
  - **RHEL/CentOS 7**: Python 2.7.x
  - **RHEL/CentOS 8+**: Python 3.6+
  - **Ubuntu 14.04/16.04**: Python 2.7.x
  - **Ubuntu 18.04+**: Python 3.6+
  - **Azure Linux**: Python 3.x
- Extension lifecycle: install → enable → update → disable → uninstall

## Code Review Checklist

When generating code, ensure:

- [ ] Cross-platform Python compatibility (2.7 and 3.x)
- [ ] Comprehensive unit tests with mocking and code coverage
- [ ] Error handling with appropriate logging
- [ ] Distribution-specific logic when applicable
- [ ] Command execution with timeout handling
- [ ] No hardcoded paths or values
- [ ] Proper inheritance from base classes
- [ ] Mock verification in tests
- [ ] Edge case coverage
- [ ] Clear, descriptive test names and docstrings

## Integration Instructions

Always consider how new code integrates with:
- Existing distribution patching classes
- Command execution framework
- Logging infrastructure  
- Configuration management
- Error handling patterns

Generate code that follows established patterns and maintains consistency with the existing codebase while ensuring robust test coverage and Python 2.7 compatibility.
