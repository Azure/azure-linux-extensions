# GitHub Copilot Instructions for Azure VM Encryption Extension

## Project Context

This is the Azure VM Encryption Extension for Linux VMs. The extension provides disk encryption capabilities across multiple Linux distributions (Ubuntu, RedHat, CentOS, Oracle Linux, Azure Linux) and must maintain compatibility with the Python versions available on each target distribution.

## Code Generation Guidelines

### 1. Python Version Compatibility

**CRITICAL**: Always write Python code compatible with the oldest Python versions found on supported Linux distributions, as the extension runs on the VM's native Python environment.

**Target Compatibility**: 
- **Python 2.7**: Still present on older distributions (RHEL 7, CentOS 7, Ubuntu 14.04)
- **Python 3.x**: Standard on newer distributions (Ubuntu 18+, RHEL 8+, Azure Linux)
- **Cross-compatibility**: Code must work on both Python 2.7 and 3.x

**DO:**
```python
# Use .format() for string formatting
message = "Package {0} installed: {1}".format(package_name, status)

# Import compatibility
try:
    import unittest.mock as mock  # Python 3+
except ImportError:
    import mock  # Python 2

# Use explicit inheritance
class MyClass(object):  # Python 2 compatibility
```

**DON'T:**
```python
# Avoid f-strings (Python 3.6+ only)
message = f"Package {package_name} installed: {status}"  # BREAKS on older distributions

# Avoid Python 3 only features
async def my_function():  # Python 3.5+ only
```

### 2. Unit Testing Requirements

**ALWAYS** generate unit tests when creating new functions or classes. Every public method should have corresponding test coverage.

#### Test File Naming Convention
- Module: `MyModule.py` → Test file: `test_MyModule.py` 
- Place in `main/test/` directory
- Class naming: `class Test_MyModule(unittest.TestCase)`

#### Required Test Template
```python
import unittest
from YourModule import YourClass
from .console_logger import ConsoleLogger

try:
    import unittest.mock as mock
except ImportError:
    import mock

class Test_YourClass(unittest.TestCase):
    def setUp(self):
        self.logger = ConsoleLogger()
        self.instance = YourClass(self.logger, required_params)
    
    @mock.patch('ExternalDependency.method')
    def test_method_success(self, mock_external):
        """Test successful execution path."""
        # Arrange
        mock_external.return_value = expected_value
        
        # Act
        result = self.instance.method_under_test()
        
        # Assert
        self.assertEqual(result, expected_result)
        mock_external.assert_called_with(expected_args)
    
    @mock.patch('ExternalDependency.method')
    def test_method_error_handling(self, mock_external):
        """Test error conditions."""
        # Test exception handling
        mock_external.side_effect = Exception("Test error")
        
        with self.assertRaises(Exception):
            self.instance.method_under_test()

if __name__ == '__main__':
    unittest.main()
```

### 3. Mocking Guidelines

**Mock all external dependencies** to ensure unit tests are isolated and fast:

#### Command Execution
```python
@mock.patch('CommandExecutor.CommandExecutor.Execute')
def test_package_installation(self, mock_execute):
    # Mock command return codes
    mock_execute.side_effect = [1, 0]  # First call fails (not installed), second succeeds
    
    result = self.patcher.install_package()
    
    # Verify exact commands called
    expected_calls = [
        mock.call("rpm -q package-name"),
        mock.call("tdnf install -y package-name", timeout=100)
    ]
    mock_execute.assert_has_calls(expected_calls)
```

#### File System Operations
```python
@mock.patch('os.path.exists')
@mock.patch('os.path.isdir')
def test_file_operations(self, mock_isdir, mock_exists):
    mock_exists.return_value = True
    mock_isdir.return_value = False
    
    # Test your file operation logic
```

#### Complex File System Scenarios
```python
from .test_utils import mock_dir_structure

@mock.patch("os.path.isdir")
@mock.patch("os.listdir")
@mock.patch("os.path.exists")
def test_device_discovery(self, exists_mock, listdir_mock, isdir_mock):
    artificial_structure = {
        "/dev/disk/azure": ["root", "scsi0"],
        "/dev/disk/azure/scsi0": ["lun0", "lun1"]
    }
    mock_dir_structure(artificial_structure, isdir_mock, listdir_mock, exists_mock)
    
    # Test device discovery logic
```

### 4. Error Handling Patterns

#### Command Execution with Timeout
```python
def execute_with_timeout(self, command, timeout_seconds=100):
    """Execute command with proper timeout handling."""
    return_code = self.command_executor.Execute(command, timeout=timeout_seconds)
    
    # Check for timeout (-9 indicates timeout)
    if return_code == -9:
        msg = "Command timed out: {0}".format(command)
        self.logger.log(msg, level='error')
        raise Exception(msg)
    
    return return_code
```

#### Package Installation Logic
```python
def install_packages(self, packages):
    """Install packages only if they're not already installed."""
    packages_to_install = []
    
    for package in packages:
        check_command = "rpm -q {0}".format(package)
        # rpm -q returns 0 when package is installed
        if self.command_executor.Execute(check_command) != 0:
            packages_to_install.append(package)
    
    if packages_to_install:
        install_command = "tdnf install -y {0}".format(" ".join(packages_to_install))
        return self.execute_with_timeout(install_command)
    
    return 0  # All packages already installed
```

### 5. Logging Patterns

Use consistent logging throughout:

```python
# Info level for normal operations
self.logger.log("Starting package installation")

# Error level for failures
self.logger.log("Package installation failed: {0}".format(error_msg), level='error')

# Avoid excessive logging in production code
# Don't log every package check - only significant events
```

### 6. Distribution-Specific Code

When creating distribution-specific patching classes:

```python
class MyDistroPatching(redhatPatching):  # Inherit from appropriate base
    def __init__(self, logger, distro_info):
        super(MyDistroPatching, self).__init__(logger, distro_info)
        self.min_version_online_encryption = '2.0'  # Set version requirements
        self.support_online_encryption = self.validate_online_encryption_support()
    
    def install_cryptsetup(self):
        """Override with distro-specific package names and commands."""
        packages = ['distro-specific-cryptsetup-package']
        # Implementation with proper error handling
    
    def install_extras(self):
        """Install additional packages needed for this distribution."""
        # Implementation that checks for existing packages first
```

### 7. Test Coverage Requirements

For every new method, create tests for:

1. **Success path**: Method works as expected
2. **Error conditions**: Handle exceptions, timeouts, missing dependencies
3. **Edge cases**: Empty inputs, boundary conditions
4. **State validation**: Verify system state after operations
5. **Mock verification**: Ensure external calls are made correctly

Example comprehensive test coverage:
```python
class Test_PackageInstaller(unittest.TestCase):
    def test_install_packages_all_installed(self):
        """Test when all packages are already installed."""
        # No installation should be attempted
    
    def test_install_packages_some_missing(self):
        """Test when some packages need installation."""
        # Only missing packages should be installed
    
    def test_install_packages_timeout(self):
        """Test timeout handling during installation."""
        # Should raise appropriate exception
    
    def test_install_packages_network_failure(self):
        """Test network failure scenarios."""
        # Should handle and report network errors
```

### 8. Common Anti-Patterns to Avoid

**DON'T:**
```python
# Don't use inverted logic for command return codes
if self.command_executor.Execute("rpm -q package"):  # WRONG - treats 0 as failure
    # This will run when package IS installed

# Don't use f-strings
error_msg = f"Failed to install {package}"  # BREAKS on Python 2.7/older distros

# Don't skip mocking in tests
def test_real_command(self):
    result = subprocess.run(["ls", "/"])  # DON'T run real commands in tests
```

**DO:**
```python
# Correct logic for command return codes
if self.command_executor.Execute("rpm -q package") != 0:  # CORRECT
    # This runs when package is NOT installed

# Use .format() for string formatting
error_msg = "Failed to install {0}".format(package)

# Mock external dependencies
@mock.patch('subprocess.run')
def test_command_execution(self, mock_run):
    mock_run.return_value = mock_result
    # Test your logic
```

## Specific Domain Knowledge

### Disk Encryption Context
- This extension encrypts Linux VM disks using LUKS (Linux Unified Key Setup)
- Supports both OS disk and data disk encryption
- Must handle various Linux distributions with different package managers
- Critical for customer data security - tests must be comprehensive

### Azure Extension Environment
- Runs in Azure VMs as a system extension on the VM's native Python environment
- Python version varies by Linux distribution:
  - **RHEL/CentOS 7**: Python 2.7.x
  - **RHEL/CentOS 8+**: Python 3.6+
  - **Ubuntu 14.04/16.04**: Python 2.7.x
  - **Ubuntu 18.04+**: Python 3.6+
  - **Azure Linux**: Python 3.x
- Limited network access during execution
- Must handle various VM configurations and sizes
- Extension lifecycle: install → enable → update → disable → uninstall

### Key Components to Test
- **Package installation**: Verify correct packages for each distribution
- **Command execution**: Test timeout and error handling
- **File system operations**: Mock all disk operations
- **Configuration parsing**: Validate Azure settings
- **Distribution detection**: Test distro-specific logic

## Code Review Checklist

When generating code, ensure:

- [ ] Cross-platform Python compatibility (2.7 and 3.x)
- [ ] Comprehensive unit tests with mocking
- [ ] Error handling with appropriate logging
- [ ] Distribution-specific logic when applicable
- [ ] Command execution with timeout handling
- [ ] No hardcoded paths or values
- [ ] Proper inheritance from base classes
- [ ] Mock verification in tests
- [ ] Edge case coverage
- [ ] Clear, descriptive test names and docstrings

## Integration Instructions

Always consider how new code integrates with:
- Existing distribution patching classes
- Command execution framework
- Logging infrastructure  
- Configuration management
- Error handling patterns

Generate code that follows established patterns and maintains consistency with the existing codebase while ensuring robust test coverage and Python 2.7 compatibility.
