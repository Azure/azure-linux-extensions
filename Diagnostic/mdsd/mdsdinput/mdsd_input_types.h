// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.


//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.3.0.5
//   File : mdsd_input_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x302
#error This file was generated by a newer version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0305
#error This file was generated by an older version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>
#include <bond/core/nullable.h>
#include <bond/core/blob.h>


namespace mdsdinput
{
    
    struct Time
    {
        uint64_t sec;
        uint32_t nsec;
        
        Time()
          : sec(),
            nsec()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Time(const Time& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        Time(Time&& other)
          : sec(std::move(other.sec)),
            nsec(std::move(other.nsec))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Time& operator=(const Time& other) = default;
#endif

        bool operator==(const Time& other) const
        {
            return true
                && (sec == other.sec)
                && (nsec == other.nsec);
        }

        bool operator!=(const Time& other) const
        {
            return !(*this == other);
        }

        void swap(Time& other)
        {
            using std::swap;
            swap(sec, other.sec);
            swap(nsec, other.nsec);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(Time& left, Time& right)
    {
        left.swap(right);
    }

    
    namespace _bond_enumerators
    {
    namespace FieldType
    {
        enum FieldType
        {
            FT_INVALID = 0,
            FT_BOOL = 1,
            FT_INT32 = 2,
            FT_INT64 = 3,
            FT_DOUBLE = 4,
            FT_TIME = 5,
            FT_STRING = 6
        };
        
        extern const std::map<enum FieldType, std::string> _value_to_name_FieldType;
        extern const std::map<std::string, enum FieldType> _name_to_value_FieldType;

        inline
        const char* GetTypeName(enum FieldType)
        {
            return "FieldType";
        }

        inline
        const char* GetTypeName(enum FieldType, const bond::qualified_name_tag&)
        {
            return "mdsdinput.FieldType";
        }

        inline
        const std::map<enum FieldType, std::string>& GetValueToNameMap(enum FieldType)
        {
            return _value_to_name_FieldType;
        }

        inline
        const std::map<std::string, enum FieldType>& GetNameToValueMap(enum FieldType)
        {
            return _name_to_value_FieldType;
        }

        const std::string& ToString(enum FieldType value);

        void FromString(const std::string& name, enum FieldType& value);

        inline
        bool ToEnum(enum FieldType& value, const std::string& name)
        {
            std::map<std::string, enum FieldType>::const_iterator it =
                _name_to_value_FieldType.find(name);

            if (_name_to_value_FieldType.end() == it)
                return false;

            value = it->second;

            return true;
        }
    } // namespace FieldType
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::FieldType;
    

    
    struct FieldDef
    {
        std::string name;
        ::mdsdinput::FieldType fieldType;
        
        FieldDef()
          : fieldType(::mdsdinput::_bond_enumerators::FieldType::FT_INVALID)
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        FieldDef(const FieldDef& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        FieldDef(FieldDef&& other)
          : name(std::move(other.name)),
            fieldType(std::move(other.fieldType))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        FieldDef& operator=(const FieldDef& other) = default;
#endif

        bool operator==(const FieldDef& other) const
        {
            return true
                && (name == other.name)
                && (fieldType == other.fieldType);
        }

        bool operator!=(const FieldDef& other) const
        {
            return !(*this == other);
        }

        void swap(FieldDef& other)
        {
            using std::swap;
            swap(name, other.name);
            swap(fieldType, other.fieldType);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(FieldDef& left, FieldDef& right)
    {
        left.swap(right);
    }

    
    struct SchemaDef
    {
        std::vector< ::mdsdinput::FieldDef> fields;
        bond::nullable<uint32_t> timestampFieldIdx;
        
        SchemaDef()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        SchemaDef(const SchemaDef& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        SchemaDef(SchemaDef&& other)
          : fields(std::move(other.fields)),
            timestampFieldIdx(std::move(other.timestampFieldIdx))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        SchemaDef& operator=(const SchemaDef& other) = default;
#endif

        bool operator==(const SchemaDef& other) const
        {
            return true
                && (fields == other.fields)
                && (timestampFieldIdx == other.timestampFieldIdx);
        }

        bool operator!=(const SchemaDef& other) const
        {
            return !(*this == other);
        }

        void swap(SchemaDef& other)
        {
            using std::swap;
            swap(fields, other.fields);
            swap(timestampFieldIdx, other.timestampFieldIdx);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(SchemaDef& left, SchemaDef& right)
    {
        left.swap(right);
    }

    
    struct Message
    {
        std::string source;
        uint64_t msgId;
        uint64_t schemaId;
        bond::nullable< ::mdsdinput::SchemaDef> schema;
        bond::blob data;
        
        Message()
          : msgId(),
            schemaId()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Message(const Message& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        Message(Message&& other)
          : source(std::move(other.source)),
            msgId(std::move(other.msgId)),
            schemaId(std::move(other.schemaId)),
            schema(std::move(other.schema)),
            data(std::move(other.data))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Message& operator=(const Message& other) = default;
#endif

        bool operator==(const Message& other) const
        {
            return true
                && (source == other.source)
                && (msgId == other.msgId)
                && (schemaId == other.schemaId)
                && (schema == other.schema)
                && (data == other.data);
        }

        bool operator!=(const Message& other) const
        {
            return !(*this == other);
        }

        void swap(Message& other)
        {
            using std::swap;
            swap(source, other.source);
            swap(msgId, other.msgId);
            swap(schemaId, other.schemaId);
            swap(schema, other.schema);
            swap(data, other.data);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(Message& left, Message& right)
    {
        left.swap(right);
    }

    
    namespace _bond_enumerators
    {
    namespace ResponseCode
    {
        enum ResponseCode
        {
            ACK_SUCCESS = 0,
            ACK_FAILED = 1,
            ACK_UNKNOWN_SCHEMA_ID = 2,
            ACK_DECODE_ERROR = 3,
            ACK_INVALID_SOURCE = 4,
            ACK_DUPLICATE_SCHEMA_ID = 5
        };
        
        extern const std::map<enum ResponseCode, std::string> _value_to_name_ResponseCode;
        extern const std::map<std::string, enum ResponseCode> _name_to_value_ResponseCode;

        inline
        const char* GetTypeName(enum ResponseCode)
        {
            return "ResponseCode";
        }

        inline
        const char* GetTypeName(enum ResponseCode, const bond::qualified_name_tag&)
        {
            return "mdsdinput.ResponseCode";
        }

        inline
        const std::map<enum ResponseCode, std::string>& GetValueToNameMap(enum ResponseCode)
        {
            return _value_to_name_ResponseCode;
        }

        inline
        const std::map<std::string, enum ResponseCode>& GetNameToValueMap(enum ResponseCode)
        {
            return _name_to_value_ResponseCode;
        }

        const std::string& ToString(enum ResponseCode value);

        void FromString(const std::string& name, enum ResponseCode& value);

        inline
        bool ToEnum(enum ResponseCode& value, const std::string& name)
        {
            std::map<std::string, enum ResponseCode>::const_iterator it =
                _name_to_value_ResponseCode.find(name);

            if (_name_to_value_ResponseCode.end() == it)
                return false;

            value = it->second;

            return true;
        }
    } // namespace ResponseCode
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::ResponseCode;
    

    
    struct Ack
    {
        uint64_t msgId;
        ::mdsdinput::ResponseCode code;
        
        Ack()
          : msgId(),
            code(::mdsdinput::_bond_enumerators::ResponseCode::ACK_SUCCESS)
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Ack(const Ack& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        Ack(Ack&& other)
          : msgId(std::move(other.msgId)),
            code(std::move(other.code))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Ack& operator=(const Ack& other) = default;
#endif

        bool operator==(const Ack& other) const
        {
            return true
                && (msgId == other.msgId)
                && (code == other.code);
        }

        bool operator!=(const Ack& other) const
        {
            return !(*this == other);
        }

        void swap(Ack& other)
        {
            using std::swap;
            swap(msgId, other.msgId);
            swap(code, other.code);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(Ack& left, Ack& right)
    {
        left.swap(right);
    }
} // namespace mdsdinput

